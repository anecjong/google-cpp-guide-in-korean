# Functions
## 입력과 출력
C++ 함수의 출력은 자연스럽게 반환 값을 통해 제공되며, 때로는 출력 매개변수를 통해서도 제공됩니다. 출력 매개변수보다 반환 값을 사용하는 것을 선호하세요. 가독성 향상이 있으며 종종 더 나은 성능을 가지게 됩니다. 값으로 반환하거나, 그것이 적절하지 않다면 참조로 반환하는 것을 선호하세요. `nullptr`이 될 수 있는 경우가 아니라면 원시 포인터 반환을 피하세요.

매개변수는 함수의 입력, 출력 또는 둘 다일 수 있습니다. 매개 변수의 작성은 아래의 테이블을 참고하세요.
|매개변수|Non-optional|Optional|
|------|---|---|
|입력|값 (T) 또는 const T&|값: std::optional<T>, 참조: const T* (null 가능)|
|출력|T& (null 불가)|T* (null 가능)|
|입출력|T& (null 불가)|T* (null 가능)|

참조 매개변수가 함수 호출 이후에도 살아있어야 하는 함수를 정의하지 마세요. 대신 생명 주기 요구 사항을 제거하는 방법(복사)를 찾거나, 유지되어야 하는 매개변수는 포인터로 전달하고 생명 주기 및 널이 아님 요구 사항을 문서화하세요.

함수 매개변수의 순서를 정의할 때 모든 입력 전용 매개변수를 출력 매개변수 앞에 두세요. 예외로 입출력 매개변수는 입력의 끝이나 출력의 끝에 위치시켜야합니다. 비슷한 함수의 매개변수 순서 일관성을 유자하도록 하세요. 가변 인자 함수도 특이한 매개변수 순서를 요구할 수 있습니다.

## 짧은 함수 작성
작고 명확한 함수를 선호하세요. 긴 함수가 때로는 적절하다는 것을 인지하고 있으므로, 함수 길이에 대한 엄격한 제한은 없습니다. 만약 함수가 약 40줄을 초과하면, 프로그램의 구조를 해치지 않으면서 나눌 수 있는지 고민해보세요.

긴 함수가 지금은 완벽하게 작동하더라도, 몇 달 후 누군가가 수정하면서 새로운 동작을 추가할 수 있습니다. 긴 함수에서는 찾기 어려운 버그를 유발할 수 있으며, 짧게 작성하는 경우에는 읽고 수정, 테스트하기 쉬워집니다. 길고 복잡한 기존 함수를 발견했을 때 이를 개선하려는 노력을 하세요.

## 함수 오버로딩
### 정의

### 장점
- 오버로딩은 동일한 이름의 함수가 서로 다른 인수를 받도록 허용하여 코드를 더 직관적으로 만들 수 있습니다. 템플릿 코드에 필요할 수 있으며 방문자 패턴(Visitor pattern)에 편리할 수 있습니다.
- `const` 또는 `&&`와 같은 참조 한정자에 기반한 오버로딩은 유틸리티 코드를 더 사용하기 쉽거나, 효율적이거나 둘 다이게 만들 수 있습니다.

### 단점
- 함수가 인수 타입으로만 오버로드되면, 리뷰어는 무슨 일이 일어나는지 파악하기 위해 C++의 복잡한 매칭 규칙을 이해해야할 수 있씁니다. 또한 파생 클래스가 함수의 일부 변형만 오버라이드할 경우 상속의 의미 체계에 혼란을 느낄 수 있습니다.

### 의사 결정
- 여러 변형 간에 의미론적 차이가 없을 때 함수를 오버로드할 수 있습니다. 이러한 오버로드는 타입, 한정자, 또는 인수 개수에서 다를 수 있습니다. 호출을 읽는 리뷰어가 오버로드 세트의 어떤 멤버가 선택되는지 알 필요 없이 세트 중 하나가 호출되었다만 알면 충분한 경우에 오버로드를 사용하세요.

## 기본 인자(Default Arguments)
### 장점
- 기본 매개변수는 드문 예외를 위해 많은 함수를 정의할 필요 없이 이를 수행할 수 있는 방법을 제공합니다. 함수를 오버로딩하는 것과 비교해서 기본 인자는 더 깔끔한 구문을 가지며 상용구(boilerplate) 코드가 적고, 필수와 선택 인수를 더 명확하게 구분합니다.
```cpp
// 기본 인자 사용
void setup(int mode, bool logging = false, int timeout = 1000);

// 오버로딩 사용
void setup(int mode);
void setup(int mode, bool logging);
void setup(int mode, bool logging, int timeout)
```
### 단점
- 기본 인자는 함수 오버로딩 의미 체계를 달성하는 또 다른 방법으로, 함수 오버로딩의 단점(호출의 모호성, 의미론적 불일치 시 혼란 등)이 동일하게 나타날 수 있습니다.
- 가상 함수 호출에서 인수의 기본값은 대상 객체의 정적 타입에 의해 결정되며, 특정 함수의 모든 오버라이드가 동일한 기본값을 선언한다는 보장이 없습니다.
```cpp
class Base
{
public:
  virtual void Foo(int x = 10)
  {
    std::cout << "Base::foo, x = " << x << std::endl;
  }
};

class Derived : public Base
{
public:
  void Foo(int x = 20) override
  {
    std::cout << "Derived::foo, x = " << x << std::endl;
  }
};
```
- 기본 매개변수는 각 호출 지점에서 재평가되어 생성된 코드 부풀림(Code bloat)을 만들 수 있습니다. 기본값이 변할 수 있는 경우 리뷰어는 함수 선언 시점의 값으로 고정될 것으로 오해할 수 있지만, 실제로는 호출 시점의 현재값이 적용됩니다.
- 함수 포인터는 기본 인자가 있을 때 함수의 시그니쳐와 호출 시그니쳐가 일치하지 않아 혼란을 줄 수 있습니다.

### 의사결정
- 기본 인자는 제대로 작동하지 않는 가상 함수와, 지정된 기본값이 언제 평가되는지에 따라 동일한 값으로 평가되지 않을 수 있는 경우(`void f(int n = counter++);`와 같은 형태)에 금지됩니다.
- 다른 일부 경우에는 기본 인자가 함수 선언의 가독성을 충분히 향상시켜 위의 단점들을 극복할 수 있으므로 허용됩니다. 확실하지 않으면 오버로드를 사용하세요.

## 후행 반환 타입 구문(Trailing Return Type Syntax)
### 정의
C++에서는 두 가지 다른 형태의 함수 선언을 허용합니다.
- `int foo(int x);`
- `auto foo(int x) -> int;`
후행 반환 타입은 함수의 스코프 내에 있어 반환 타입을 명시할 때 함수 매개변수나 클래스 멤버를 참조(`auto foo(MyClass obj) -> decltype(obj.memberType);`)할 수 있습니다. 선행 반환 타입 위치에서는 아직 매개변수가 선언되지 않았으므로 이렇게 할 수 없습니다.

### 장점
- 람다 표현식에서 반환 타입을 명시해야 할 때 후행 반환 타입 구문만 가능합니다.
- 템플릿 함수에서 반환 타입이 매개변수들의 연산 결과에 따라 결정될 때 (`SFINAE` 또는 `decltype` 사용), 후행 반환 타입을 사용하면 코드가 훨씬 깔끔해집니다.
```cpp
template <typename T, typename U>
auto add(T t, U u) -> decltype(t + u);

template <typename T, typename U>
decltype(declval<T&>() + declval<U&>()) add(T t, U u);
```

### 단점
- C++11에서 도입되었으므로, 그 이전 C++에 익숙하거나 다른 언어 배경을 가진 프로그래머에게는 낯설게 느껴질 수 있습니다.
- 모든 함수 선언을 후행 반환 타입으로 바꾸는 것은 비현실적이므로, 불가피하게 두 가지 스타일이 혼재될 수 있습니다. 스타일의 통일성을 위해서는 단일 버전을 사용하는게 좋습니다.

### 의사 결정
- 특별한 이유가 없다면 선행 반환 타입 구문을 사용하세요.
- 후행 반환 타입을 사용할 수 있는 예외는 아래와 같습니다.
    - 람다 표현식에서 반환 타입을 명시
    - 복잡한 템플릿에서 반환 타입이 매개변수에 의존해 `decltype`을 사용할 때