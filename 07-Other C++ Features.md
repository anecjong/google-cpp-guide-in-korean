# Other C++ Features
## Rvalue 레퍼런스
### 정의
Rvalue(우측값)은 주로 이름이 없고 곧 사라질 임시 값이나 `std::move`를 통해 명시적으로 rvalue로 캐스팅된 객체를 의미합니다. Rvalue 레퍼런스는 임시 객체에만 바인딩될 수 있는 특별한 종류의 레퍼런스로 `&&`를 사용합니다.

템플릿과 함께 사용될 때 `T&&`는 특별하게 동작합니다. 전달된 인자가 lvalue이면 `T`는 lvalue 레퍼런스(`T&`)로 추론되고, rvalue이면 레퍼런스가 아닌 타입(`int`)으로 추론됩니다. 이는 인자의 카테고리를 보존하며 다른 함수로 전달(perfect forwarding)하는데 사용됩니다.

### 장점
- 이동 생성자를 정의하면 객체의 내용을 깊은 복사하는 대신 이동할 수 있습니다.
- Rvalue 레퍼런스를 사용하면 복사는 불가능하지만 이동은 가능한 타입을 구현할 수 있습니다. (뮤텍스, 파일 핸들, `std::unique_ptr`처럼 소유권 개념이 중요하고 복사가 부적절한 타입들)
- `std::move`는 특정 객체를 rvalue로 취급하도록 컴파일러에게 알려주는 캐스팅 연산으로 `std::unique_ptr`과 같은 일부 표준 라이브러리 타입을 효과적으로 사용하기 위해 필수적입니다.
- Rvalue 레퍼런스 토큰을 사용하는 전달 레퍼런스는 `std::forward`와 함께 사용되어 전달받은 인자가 임시 객체인지 아닌지, `const`인지 아닌지를 정확히 보존하면서 다른 함수로 인수를 전달하는 완벽한 전달을 작성할 수 있습니다.

### 단점
- Rvalue 레퍼런스는 아직 널리 이해되지 않았습니다.
- Rvalue 레퍼런스는 종종 잘못 사용될 수 있습니다. `void Process(MyType&& data);`로 해놓으면, 이 객체의 내용을 가져가도 좋다고 이해되지만 함수 내부에서 처리되지 않은 경우 혼란을 야기할 수 있습니다.

### 의사결정
다음과 같은 경우를 제외하고는 rvalue 레퍼런스를 사용하의나 메서드에 `&&`를 사용하지 마세요.
- 이동 생성자 및 이동 대입 연산자 정의: `ClassName(ClassName&& other)`, `ClassName& operator=(ClassName&& other)`
- `*this`를 소비하는 `&&` 메서드 정의: 메서드 시그니쳐 뒤에 `&&`를 붙여 해당 메서드가 rvalue 객체에 대해서만 호출될 수록 제한할 수 있습니다. 이러한 메서드는 논리적으로 `*this` 객체를 소비해 호출 후 사용할 수 없거나 빈 상태가 되도록 만듭니다.
- 완벽한 전달을 위한 전달 레퍼런스 사용: `template<typename T> void func(T&& arg) { other_func(std::forward<T>(arg)); }`
- 오버로드 쌍 정의: 일반적으로 값으로 전달이 선호되지만 최적화 등의 상황에서 사용할 수 있습니다. 이 목적으로 사용하는 경우 실제 성능 향상에 도움이 된다는 증거를 확보해야 합니다.

## Friend
C++에서 friend 키워드를 사용하여 선언된 클래스나 함수는, 해당 선언을 포함하는 클래스의 `private` 및 `protected` 멤버에 접근할 수 있는 특별한 권한을 가집니다. 일반적으로 `friend`는 같은 파일 내에 정의해 리뷰어가 다른 파일을 찾아볼 필요가 없도록 합니다.

`friend`의 일반적인 사용 예로는 빌더 패턴이 있으며 경우에 따라서는 유닛 테스트 클래스를 테스트 대상 클래스의 `friend`로 만드는 것이 유용할 수 있습니다. `friend`는 클래스의 캡슐화 경계를 확장하지만 깨뜨리지는 않습니다. 해당 멤버를 `public`으로 만드는 것보다 `friend`를 사용하는 것이 더 나은 경우가 있지만, 대부분의 경우에는 `public` 멤버를 통해서만 다른 클래스와 상호작용해야 합니다.

## Exceptions
### 장점
- 예외는 오류 코드를 사용하는 번거롭고 오류 발생 가능성이 높은 기록 작업 없이, 애플리케이션의 상위 레벨에서 일어나서는 안 되는 실패를 처리하는 방법을 결정할 수 있게 합니다.
- 예외는 대부분의 다른 현대 언어에서 사용됩니다. Python, Java 등 일관성을 높일 수 있습니다.
- 일부 서드파티 라이브러리는 예외를 사용하며, 내부적으로 이를 끄면 해당 라이브러리와 통합이 어려워집니다.
- 예외는 생성자가 실패했음을 알릴 수 있는 유일한 방법 입니다.
- 예외는 테스트 프레임워크에서 유용합니다.
### 단점
- 기존 함수에 `throw` 문을 추가하면, 모든 호출자를 검토해야 합니다.
- 예외는 코드만 보고 프로그램의 제어 흐름을 평가하기 어렵게 만듭니다. 이는 유지보수성과 디버깅의 어려움으로 이어질 수 있습니다.
- 예외 안전성은 RAII 패턴과 특별한 코딩 관행이 필요합니다. 예외 안전 코드를 작성하는 것은 복잡하며, 영구적인 상태 변경은 커밋 단계로 분리해야 하는 등 추가적인 노력이 필요합니다.
- 예외를 활성화하면 각 바이너리에 데이터가 추가되어 컴파일 시간이 증가하고 주소 공간 사용량 증가로 이어질 수 있습니다.
- 예외를 사용할 수 있다는 점은 개발자들이 부적절한 상황에서 예외를 던지거나, 안전하지 않은 방식으로 복구하려고 시도할 수 있습니다.
### 의사 결정
- 표면적으로는 특히 새로운 프로젝트에서 예외 사용의 이점이 비용보다 큽니다. Google의 기존 C++ 코드 대부분은 예외를 처리할 준비가 되어 있지 않기 때문에, 예외를 발생시키는 새 코드를 채택하는 것은 상대적으로 어렵습니다.
- Google은 예외 자체의 장점을 인정하지만, 방대한 레거시 코드베이스와 호환성, 통합 비용, 예외 안전 코드 작성의 복잡성 등 실질적인 이유로 C++ 예외를 사용하지 않습니다.

## noexcept
### 정의
`noexcept` 지정자는 함수가 예외를 던질지 여부를 명시하는 데 사용합니다. 만약 `noexcept`로 표시된 함수에서 예외가 발생하면 프로그램은 `std::terminate`를 통해 비정상 종료됩니다.
### 장점
- 이동 생성자를 `noexcept`로 지정하면 일부 경우 성능이 향상됩니다. 예를 들어, `T`의 이동 생성자가 `noexcept`이면 `std::vector<T>::resize()`는 객체를 복사하는 대신 이동시킵니다.
- 함수에 `noexcept`를 지정하면 예외가 활성화된 환경에서 컴파일러 최적화를 유발할 수 있습니다. 예를 들어, 컴파일러는 `noexcept` 지정자로 인해 예외가 발생하지 않는다는 것을 알면 스택 풀기(stack-unwinding)를 위한 추가 코드를 생성할 필요가 없습니다.
### 단점
- 예외가 비활성화된 Google 스타일 가이드를 따르는 프로젝트에서는 `noexcept` 지정자가 올바르다는 것을 보장하기 어렵습니다.
- `noexcept`는 호출자들이 감지하기 어려운 방식으로 의존하고 있을 수 있는 예외를 던지지 않는다는 보장을 제공하는데, `noexcept`를 제거하면 이 보장이 사라지므로, 한번 적용된 `noexcept`를 되돌리는 것은 거의 불가능합니다.
### 의사 결정
함수의 의도된 의미론을 정확하게 반영하고 성능에 유용할 때 `noexcept`를 사용할 수 있습니다. 이동 생성자에 `noexcept`를 사용하는 것은 의미 있는 성능 이점이 있다고 가정할 수 있습니다. 다른 함수에 `noexcept`를 지정하여 상당한 성능 이점이 있다고 생각되면 프로젝트 리더와 논의하세요.

많은 경우, 예외의 유일한 원인은 메모리 할당 실패입니다. Google은 이동 생성자가 할당 실패 외의 이유로 예외를 던져서는 안 된다고 보고, 메모리 부족은 프로그램이 복구해야 할 예외 상황이라기보다는 치명적 오류로 간주하는 것이 적절한 경우가 많다고 봅니다.

## RTTI(Run-Time Type Information)
### 정의
RTTI는 프로그래머가 런타임에 객체의 C++ 클래스를 질의할 수 있게 합니다. `typeid` 또는 `dynamic_cast`를 사용하여 수행됩니다.

### 장점
- RTTI의 대안들은 해당 클래스 계층의 수정이나 재설계를 필요로 합니다. 이러한 수정은 널리 사용되거나 오래된 코드에서 실행 불가능하거나 바람직하지 않을 수 있습니다.
- RTTI는 유닛테스트에서 유용합니다. 예를 들어 팩토리 클래스에서 생성된 객체가 실제 예상되는 타입을 가지고 있는지 확인할 때 사용할 수 있으며 객체와 객체의 mock 관계를 관리할 때도 유용합니다.
- RTTI는 여러 추상 객체를 고려할 때 유용합니다.
```cpp
bool Base::Equal(Base* other) = 0; // 순수 가상 함수
bool Derived::Equal(Base* other)
{
  Derived* that = dynamic_cast<Derived*>(other); // other가 실제로 Derived 타입인지 확인
  if (that == nullptr)                           // Derived 타입이 아니라면 nullptr 반환
  {
    return false; // 다른 타입이므로 같지 않음
  }
  // ... Derived 타입의 멤버들을 비교하는 로직
}
```
위 예시에서 `Derived::Equal` 함수는 `other`이 `Derived` 타입이거나 상속 받은 경우 변환해주고, 그렇지 않으면 `nullptr`를 반환합니다.

### 단점
- 런타임에 객체의 타입을 질의하는 것은 설계 문제를 의미할 수 있습니다.
- RTTI를 무분별하게 사용하면 코드 유지 보수가 어려워집니다. 타입 기반의 의사 결정 트리나 `switch` 문이 코드 전체에 흩어질 수 있으며 추후 변경 시 모두 검토해야 합니다.

### 의사 결정
RTTI는 정당한 사용 사례가 있지만 남용되기 쉬우므로 피해야 합니다. 유닛 테스트에서는 자유롭게 사용할 수 있지만, 다른 코드에서는 가능하면 피해야 합니다. 객체의 클래스에 따라 다르게 동작하는 코드를 작성해야 한다면, RTTI 대신 아래를 고려하세요.

- 가상 메서드: 가정 선호되는 방법입니다. 작업을 객체 내부에 두세요.
- 이중 디스패치 솔루션(방문자 패턴): 작업이 객체 외부에 있고 어떤 처리 코드에 속한다면, 방문자 디자인 패턴 등을 고려하세요.
- 타입 보장시 `dynamic_cast` 사용: 프로그램의 로직이 특정 기반 클래스임을 보장하는 경우, 해당 객체에  `dynamic_cast`를 자유롭게 사용하세요.

타입에 기반한 의사 결정 트리는 코드가 잘못된 방향으로 가고 있다는 강력한 신호입니다.
```cpp
if (typeid(*data) == typeid(D1))
{
  // ... D1 타입에 대한 처리
}
else if (typeid(*data) == typeid(D2))
{
  // ... D2 타입에 대한 처리
}
else if (typeid(*data) == typeid(D3))
{
  // ... D3 타입에 대한 처리
}
// ...
```

## 캐스팅
### 정의
C++는 C와는 다른 캐스트 시스템을 도입하여, 캐스트 연산의 종류를 구별합니다.

### 장점
- C 스타일 캐스트는 연산의 모호성 문제가 있습니다. `(int)3.5`처럼 값 변환을 의미할 수도 있고 `(int)"hello"`와 같이 타입의 재해석이 수행될 수 있습니다.
- C++ 스타일 캐스트는 이러한 모호성을 피하는데 도움을 주고, 코드 내에서 검색할 때 눈에 더 쉽게 확인할 수 있습니다.

### 단점
- C++ 스타일 캐스트 문법은 장황하고 번거롭습니다.

### 의사결정
일반적으로 C 스타일 캐스트를 사용하지 마세요. 명시적인 타입 변환이 필요할 때는 다음의 C++ 스타일 캐스트를 사용하세요.
- 산술 타입을 변환할 때는 중괄호 초기화를 사용하세요. `int64_t{x}`와 같은 방법은 정보 손실이 발생할 수 있으면 코드가 컴파일되지 않아 가장 안전합니다.
- 클래스 타입으로 명시적으로 변환할 때는 함수 스타일 캐스트를 사용하세요. (`static_cast<std::string> a` 대신 `std::string(a)`를 사용하세요.)
- 타입 계층 구조에서 안전하게 상위 클래스로 캐스팅할 때는 `absl::implicit_cast`를 사용하세요.
- `static_cast`는 C 스타일의 값 변환, 상위클래스로 업캐스팅, 하위클래스로 다운캐스팅할 때 사용하세요. 마지막 경우, 해당 객체가 실제로 하위 클래스의 인스턴스임을 확신해야 합니다.
- `const_cast`는 `const` 한정자를 제거하기 위해 사용합니다.
- `reinterpret_cast`는 포인터 타입을 정수나 다른 포인터 타입으로 안전하지 않은 변환을 수행하기 위해 사용합니다. 무엇을 하고 있는지 알고 있고 앨리어싱 문제를 이용한 경우에만 사용하세요. 또한, 포인터를 (캐스트 없이) 역참조하고 `std::bit_cast`를 사용하여 결과 값을 캐스팅하는 것을 고려해 보세요.
- `std::bit_cast`는 같은 크기를 가진 다른 타입으로 값의 원시 비트를 재해석하기 위해 사용합니다. - C++20
- `dynamic_cast`의 사용지침은 RTTI 섹션을 참조하세요.

## 스트림(Streams)
### 정의
스트림은 C++의 표준 I/O 추상화이며, 표준 헤더 `<iostream>`이 그 예입니다. 구글 코드에서 널리 사용되며, 주로 디버그 로깅 및 테스트 진단에 사용됩니다.

### 장점
- `<<`, `>>`는 배우고 쉽고, 이식 가능하며, 재사용 가능하고, 확장 가능한 형식화된 I/O API를 제공합니다. `printf`는 `std::string`도 지원하지 않아 이식성 있게 사용하기 어렵습니다.
- 스트림은 `std::cin`, `std::cout`, `std::cerr`, `std::clog`를 통해 콘솔 I/O를 일급으로 지원합니다. C API도 마찬가지지만, 입력을 수동으로 버퍼링해야하는 단점이 있습니다.

### 단점
- 스트림의 상태를 변경해 스트림 형식을 구성할 수 있습니다. 이러한 변경은 지속적이므로 다른 코드가 스트림을 건드렸을 수 있을 때마다 알려진 상태로 복원의 노력이 없다면 이전 기록에 의해 영향을 받을 수 있습니다.
- 스트리밍 코드에서 코드와 데이터가 혼합되고 연산자 오버로딩 사용으로 인해 스트림 출력을 정밀하게 제어하기 어렵습니다.
- `<<` 연산자 체인을 통해 출력을 구성하는 방식은 국제화를 방해합니다.
- 스트림 API는 미묘하고 복잡하므로, 프로그래머는 이를 효과적으로 사용하기 위해 경험을 쌓아야 합니다.
- `<<`의 많은 오버로드를 해결하는 것은 컴파일러에게 비용이 많이 드는 작업입니다.

### 의사 결정
스트림은 개발자 대상의 간단한 로깅, 테스트에만 사용하는 것이 좋습니다. 진단 출력에는 특히 로깅 라이브러리가 더 나은 선택인 경우가 많습니다.

## 전위 증가 및 전위 감소
### 정의
변수가 증가(`++i` 또는 `i++`) 또는 감소(`--i` 또는 `i--`)되고 그 표현식의 값이 사용되지 않을 때, 전위 증가(감소)를 사용할지 후위 증가(감소)를 사용할지 결정해야 합니다.

### 장점
후위 증가/감소 표현식은 수정되기 전의 값으로 평가됩니다. 이는 코드를 더 간결하게 만들 수 있지만 읽기 어렵게 만들 수 있습니다. 전위 형태는 일반적으로 더 읽기 쉽고, 결코 덜 효율적이지 않으며, 연산 이전의 값을 복사할 필요가 없기 때문에 더 효율적일 수 있습니다.

### 단점
C에서는 표현식 값이 사용되지 않는 경우에도, 특히 `for` 루프에서 후위 증가를 사용하는 관행이 발전해 왔습니다.

### 의사결정
코드가 명시적으로 후위 증가/감소 표현식의 결과를 필요로 하지 않는 한, 전위 증가/감소를 사용하세요.

### `const` 사용법
### 정의
선언된 변수와 매개변수 앞에 `const` 키워드를 붙여 해당 변수가 변경되지 않음을 나타낼 수 있습니다. 클래스 함수는 `const` 한정자를 가져 해당 함수가 클래스 멤버 변수의 상태를 변경하지 않음을 나타낼 수 있습니다.
### 장점
- 사람들이 변수가 어떻게 사용되는지 더 쉽게 이해할 수 있습니다.
- 컴파일러가 더 나은 타입 검사를 수행하고, 이론적으로 더 나은 코드를 생성할 수 있게 합니다.
- 호출하는 함수가 변수를 수정하는 방식에 제한이 있다는 것을 알아 프로그래머가 프로그램의 정확성을 확신하는데 도움이 됩니다.
- 멀티스레드 프로그램에서 락 없이 안전하게 사용할 수 있는 함수를 쉽게 식별할 수 있습니다.

### 단점
- `const`는 전염성이 있어 `const` 변수를 함수에 전달하면, 해당 함수의 원형에도 `const`가 있어야 합니다.

### 의사 결정
API에서는 가능하다면 어디든 `const`를 사용할 것을 강력히 권장합니다. 
- 함수가 참조나 포인터로 전달된 인수를 수정하지 않을 것을 보장한다면, 상수 참조(`const T&`) 또는 상수 포인터(`const T*`)여야 합니다.
- 값으로 전달되는 함수 매개변수의 경우, `const`는 호출자에게 아무런 영향을 미치지 않으므로 함수 선언에서는 권장되지 않습니다.
- 메서드가 객체의 논리적 상태를 변경하거나 동시에 안전하게 호출될 수 없는 경우가 아니라면 `const`로 선언하세요.
- 지역 변수에 `const`를 사용하는 것은 권장하거나, 권장되지 않는 것이 아닙니다.

클래스의 모든 `const` 연산은 서로 동시에 안전하게 호출될 수 있어야 하며, 이것이 불가능하다면 해당 클래스는 스레드 안전하지 않음으로 문서화되어야 합니다.

## `constexpr`, `constinit`, `consteval` 사용법
### 정의
일부 변수는 `constexpr`로 선언되어 해당 변수가 진정한 상수, 즉 컴파일/링크 시점에 고정됨을 나타낼 수 있습니다. 일부 함수와 생성자는 `constexpr`로 선언될 수 있으며, 이를 통해 `constexpr` 변수를 정의하는 데 사용될 수 있습니다. 함수는 `consteval`로 선언되어 그 사용을 컴파일 시간으로 제한할 수 있습니다.

### 장점
- `constexpr` 사용은 단순 리터럴뿐만 아니라 부동 소수점 표현식을 사용한 상수 정의, 사용자 정의 타입의 상수 정의, 그리고 함수 호출을 사용한 상수 정의를 가능하게 합니다.

### 단점
- 어떤 것을 성급하게 `constexpr`로 표시하면 나중에 이를 다운그레이드해야 할 경우 마이그레이션 문제를 일으킬 수 있습니다. `constexpr` 함수 및 생성자에서 허용되는 것에 대한 현재의 제약 사항은 이러한 정의에서 모호한 임시방편(workaround)을 유발할 수 있습니다.

### 결정
`constexpr` 정의는 인터페이스의 상수 부분을 더 견고하게 명시할 수 있게 합니다. 진정한 상수와 그 정의를 지원하는 함수를 명시하기 위해 `constexpr`을 사용하세요. 런타임에 호출되어서는 안 되는 코드에는 `consteval`을 사용할 수 있습니다. `constexpr`과 함께 사용하기 위해 함수 정의를 복잡하게 만들지 마세요. 인라인을 강제하기 위해 `constexpr`이나 `consteval`을 사용하지 마세요.

## 정수 타입
### 정의
C++는 `int`와 같은 정수 타입에 대해 정확한 크기를 명시하지 않습니다. 현대 아키텍처에서 일반적인 크기는 `short`는 16비트, `int`는 32비트, `long`은 32비트 또는 64비트, `long long`은 64비트이지만, 플랫폼마다 특히 `long`에 대해 다른 선택을 합니다.

### 장점
- 선언이 통일성이 있습니다.

### 단점
- C++에서 정수 타입의 크기는 컴파일러와 아키텍처에 따라 달라질 수 있습니다.

### 의사 결정
표준 라이브러리 헤더 `<stdint.h>` (C++에서는 `<cstdint>`)는 `int16_t`, `uint32_t`, `int64_t` 등과 같은 타입을 정의합니다. 정수의 크기에 대한 보장이 필요할 때는 `short`, `unsigned long long` 등 대신 항상 이러한 타입을 우선적으로 사용해야 합니다. 이 타입들에 대해 `std::` 접두사는 생략하는 것이 선호됩니다. 추가적인 5글자가 야기하는 불필요한 혼잡을 감수할 가치가 없기 때문입니다. 내장 정수 타입 중에서는 `int`만 사용해야 합니다. 적절한 경우, `size_t`나 `ptrdiff_t`와 같은 표준 타입 별칭을 사용하는 것은 환영입니다.

"클" 수 있다고 알고 있는 정수에는 `int64_t`를 사용하세요. 확실하지 않다면 작은 타입보다는 큰 타입을 사용하세요.

숫자가 아닌 비트 패턴을 나타내거나 오버플로우가 정의되어야 하는 타당한 이유가 없는한, `uint32_t`와 같은 부호 없는 정수 타입은 사용하지 마세요. 0보다 큰 수를 표현하기위해 이런 타입을 사용하지 마세요. 부호 없는 정수를 사용하는 것은 컴파일러가 상당한 종류의 버그를 진단할 수 없다는 것을 의미합니다.

**역사적인 실수 (컨테이너 크기)**

C++ 표준 라이브러리 컨테이너(예: `std::vector`)의 `size()` 메서드가 `size_t` (보통 부호 없는 정수 타입)를 반환하는 것은 많은 사람들이 실수로 간주합니다. 크기는 당연히 음수일 수 없지만, 이로 인해 위에서 언급된 부호 있는/없는 정수 혼합 사용 시의 문제들이 자주 발생합니다. (예: `for (int i = 0; i < vec.size(); ++i)` 같은 코드에서 `vec.size()`가 매우 크고 i가 음수가 될 수 있는 경우 등)

## 부동 소수점 타입
C++ 내장 부동 소수점 타입 중에서는 `float`과 `double`만 사용합니다. 이 타입들이 각각 IEEE-754 binary32와 binary64를 나타내는 것으로 보아도 좋습니다. `long double`은 이식성이 없으므로 사용하지 마세요.

## 아키텍쳐 이식성
다른 아키텍쳐에 이식 가능한 코드를 작성하세요. 단일 프로세서에 특화된 기능을 사용하지 마세요.

- 값을 출력할 때는 `printf` 계열 함수 대신 `std::ostream`과 같은 타입에 안전한 포매팅 라이브러리를 사용하세요.
- 구조화된 데이터를 프로세스 내부나 외부로 보낼 때는 메모리 내 표현을 그대로 복사하는 대신 프로토콜 버퍼와 같은 직렬화 라이브러리를 사용해 인코딩하세요.
- 메모리 주소를 정수로 다뤄야 한다면, `uint32_t`, `uint64_t` 대신 `uintptr_t`에 저장하세요.
- `long double`, `short`, `long`, `long long`은 피하세요.

## 전처리기 매크로
매크로의 사용을 최대한 피하세요. 인라인 함수, 열거형(`enum`), `const` 변수를 대신 사용하세요. C++ API 일부를 정의하기 위해 매크로를 사용하지 마세요.

매크로는 컴파일러가 보는 코드와 사용자가 보는 코드가 같지 않다는 것을 의미합니다. 매크로로 인해 발생하는 문제는 C++ API 일부를 저의하는데 사용할 때 특히 심각합니다. 리팩토링 및 분석 도구는 인터페이스를 업데이트하는 것이 더 어려워질 수 있습니다.

- `.h` 파일에서 매크로를 정의하지 마세요.
- 매크로를 사용하기 직전에 `#define` 하고, 사용 직후에 `#undef` 하세요.
- 기존 매크로를 자신만의 것으로 대체하기 전에 그냥 `#undef` 하지 마세요; 대신, 고유할 가능성이 높은 이름을 선택하세요.
- 균형이 맞지 않는 C++ 구문으로 확장되는 매크로를 사용하지 않도록 노력하거나, 적어도 그러한 동작을 잘 문서화하세요.
- 함수/클래스/변수 이름을 생성하기 위해 ##를 사용하지 않는 것을 선호하세요.


## 0과 `nullptr`/`NULL`
포인터에는 `nullptr`을 사용하고, 문자에는 `'\0'`을 사용하세요 (`0` 리터럴은 사용하지 마세요).

## `sizeof`
`sizeof(type)` 보다 `sizeof(varname)`을 선호하세요. 특정 변수의 크기를 가져올 때는 `sizeof(varname)`을 사용하세요. `sizeof(varname)`은 누군가가 지금이든 나중에든 변수 타입을 변경하면 적절하게 업데이트됩니다. 특정 변수와 관련 없는 코드, 예를 들어 적절한 C++ 타입의 변수가 편리하지 않은 외부 또는 내부 데이터 형식을 관리하는 코드에는 `sizeof(type)`을 사용할 수 있습니다.

## 타입 추론 (`auto` 포함)
프로젝트에 익숙하지 않은 독자에게 코드를 더 명확하게 만들거나 코드를 더 안전하게 만드는 경우에만 타입 추론을 사용하세요. 단순히 명시적인 타입을 작성하는 불편함을 피하기 위해 사용하지 마세요.

### 정의
- 함수 템플릿 인수 추론 (Function template argument deduction)
```cpp
template <typename T>
void f(T t);

f(0);  // f<int>(0)를 호출함
```
- auto 변수 선언 (auto variable declarations)
```cpp
auto a = 42;  // a는 int
auto& b = a;  // b는 int&
auto c = b;   // c는 int
auto d{42};   // d는 int (std::initializer_list<int>가 아님)
```
- 함수 반환 타입 추론 (Function return type deduction)
```cpp
auto f() { return 0; }  // f의 반환 타입은 int
```
- 제네릭 람다 (Generic lamdas)
```cpp
// vec을 내림차순으로 정렬
std::sort(vec.begin(), vec.end(), [](auto lhs, auto rhs) { return lhs > rhs; });
```
- 람다 초기화 캡처 (Lambda init captures)
```cpp
[x = 42, y = "foo"] { ... }  // x는 int, y는 const char*
```
- 구조적 바인딩 (Structured bindings)
```cpp
auto [iter, success] = my_map.insert({key, value});
if (!success)
{
  iter->second = value;
}
```

### 장점
- C++ 타입 이름은 특히 템플릿이나 네임스페이스를 포함할 때 길고 번거로울 수 있습니다.
- C++ 타입 이름이 단일 선언이나 작은 코드 영역 내에서 반복될 때, 그 반복이 가독성에 도움이 되지 않을 수 있습니다.
- 의도치 않은 복사나 타입 변환의 가능성을 피할 수 있기 때문에 타입을 추론하도록 하는 것이 때때로 더 안전합니다.

### 단점
- C++ 코드는 특히 타입 추론이 코드의 멀리 떨어진 부분의 정보에 의존할 경우, 타입이 명시적일 때 보통 더 명확합니다.
- 프로그래머는 타입 추론이 참조 타입을 생성할지 여부를 이해해야 하며, 그렇지 않으면 의도치 않은 복사가 발생할 수 있습니다.
- 추론된 타입이 인터페이스의 일부로 사용되면, 프로그래머가 단지 값을 변경하려고 했을 뿐인데 타입을 변경하게 되어 의도한 것보다 더 급격한 API 변경을 초래할 수 있습니다.

### 의사 결정
타입 추론은 코드를 더 명확하게 만들거나 더 안전하게 만드는 경우에만 사용하고, 단순히 명시적인 타입을 작성하는 불편함을 피하기 위해 사용하지 마세요. 코드가 더 명확한지 판단할 때, 독자가 반드시 여러분의 팀원이거나 프로젝트에 익숙하지 않을 수 있다는 점을 명심하세요. 따라서 여러분과 리뷰어에게는 불필요한 군더더기로 느껴지는 타입이 다른 사람들에게는 종종 유용한 정보를 제공할 것입니다. 예를 들어, `std::make_unique<Foo>()`의 반환 타입은 명백하다고 가정할 수 있지만, `MyWidgetFactory()`의 반환 타입은 그렇지 않습니다.

- 함수 템플릿 인수 추론 (Function template argument deduction)

함수 템플릿 인수 추론은 거의 항상 괜찮습니다. 

- 지역 변수 타입 추론

지역 변수의 경우, 명백하거나 관련 없는 타입 정보를 제거하여 코드를 더 명확하게 만들기 위해 타입 추론을 사용할 수 있습니다.
```cpp
// 타입 작성
std::unique_ptr<WidgetWithBellsAndWhistles> widget = std::make_unique<WidgetWithBellsAndWhistles>(arg1, arg2);

// 타입 추론
auto widget = std::make_unique<WidgetWithBellsAndWhistles>(arg1, arg2);
```
- 반환 타입 추론

함수와 람다 모두 함수 본문에 반환문이 매우 적고 다른 코드가 거의 없는 경우에만 반환 타입 추론을 사용하세요. 그렇지 않으면 독자가 반환 타입을 한눈에 파악하지 못할 수 있습니다.

함수나 람다가 매우 좁은 범위(scope)를 가질 경우에만 사용하세요. 추론된 반환 타입을 가진 함수는 추상화 경계를 정의하지 않기 때문에 구현하는 즉시 인터페이스가 됩니다. 특히, 헤더 파일의 공개 함수는 거의 절대로 추론된 반환 타입을 가져서는 안 됩니다.

- 람다 초기화 캡처 (Lambda init captures)

초기화 캡처는 더 구체적인 스타일 규칙의 적용을 받으며, 이는 타입 추론에 대한 일반 규칙을 대부분 대체합니다.

- 람다 `auto` 매개변수 (제네릭 람다):

실제 타입은 호출 시점에 결정되기 때문에 람다가 정의된 곳 바로 근처에서 호출되거나 `std::sort`의 비교 함수처럼 사용처가 명확해 어떤 타입이 들어올지 예측 가능한 경우에만 사용합니다. 그 외에는 명시적인 매개변수 타입이 더 낫습니다.

- 구조적 바인딩 (Structured bindings)

다른 형태의 타입 추론과 달리, 구조적 바인딩은 실제로 더 큰 객체의 요소에 의미 있는 이름을 부여함으로써 독자에게 추가 정보를 제공할 수 있습니다. `auto`가 그렇지 않은 경우에도 구조적 바인딩 선언이 명시적인 타입보다 순 가독성 향상을 제공할 수 있음을 의미합니다.

객체가 페어(`std::pair`)나 튜플(`std::tuple`)인 경우 구조적 바인딩은 특히 유익합니다. 하지만 `insert`와 같은 기존 API가 강제하지 않는 한 일반적으로 페어나 튜플을 사용해서는 안 된다는 점에 유의하세요.

바인딩되는 객체가 구조체인 경우, 사용 방식에 더 특정한 이름을 제공하는 것이 때때로 도움이 될 수 있지만, 이는 또한 독자에게 필드 이름보다 잘 이해되지 않을 수 있음을 유의하세요. 바인딩 이름과 일치하지 않는 경우, 함수 매개변수 주석과 동일한 구문을 사용하여 기본 필드의 이름을 나타내는 주석을 사용하는 것이 좋습니다.
```cpp
auto [/*field_name1=*/bound_name1, /*field_name2=*/bound_name2] = ...
```

## 클래스 템플릿 인수 추론(Class Template Argument Deduction)
### 정의
클래스 템플릿 인수 추론(종종 "CTAD"로 축약됨)은 변수가 템플릿 이름을 가진 타입으로 선언되고 템플릿 인수 목록이 제공되지 않을 때 (빈 꺾쇠괄호조차 없을 때) 발생합니다.
```cpp
std::array a = {1, 2, 3};  // `a`는 std::array<int, 3>
```

CTAD에 의존하는 변수를 선언하면, 컴파일러는 생성자 오버로드 확인 규칙을 사용하여 추론 가이드를 선택하고, 해당 가이드의 반환 타입이 변수의 타입이 됩니다.

### 장점
- CTAD는 때때로 코드에서 상용구(boilerplate)를 생략할 수 있게 해줍니다.

### 단점
- 생성자로부터 생성되는 암시적 추론 가이드는 바람직하지 않은 동작을 하거나 완전히 잘못될 수 있습니다. 이는 특히 C++17에서 CTAD가 도입되기 전에 작성된 생성자의 경우 문제가 됩니다.
- CTAD는 또한 `auto`와 많은 동일한 단점을 겪습니다. 둘 다 변수 타입의 전부 또는 일부를 초기화 표현식으로부터 추론하는 메커니즘으로 CTAD는 `auto`보다 독자에게 더 많은 정보를 제공하지만, 정보가 생략되었다는 명확한 신호를 독자에게 제공하지도 않습니다.
### 의사 결정
주어진 템플릿에 대해 CTAD를 사용하지 마세요. 단, 해당 템플릿의 유지보수자가 최소한 하나의 명시적 추론 가이드를 제공함으로써 CTAD 사용을 지원하기로 선택한 경우는 예외입니다 (`std` 네임스페이스의 모든 템플릿도 지원하기로 선택한 것으로 간주합니다). 가능하다면 컴파일러 경고를 통해 이를 강제해야 합니다.

## 지정 초기화자(Designated Initializer)
지정 초기화자는 C++20 호환 형태로만 사용하세요.

### 정의
지정 초기화자는 필드 이름을 명시적으로 지정하여 집합체("plain old struct", 즉 단순 구조체)를 초기화할 수 있게 하는 구문입니다.

```cpp
struct Point {
  float x = 0.0;
  float y = 0.0;
  float z = 0.0;
};

Point p = {
  .x = 1.0,
  .y = 2.0,
  // z는 0.0으로 초기화됨
};
```

명시적으로 나열된 필드는 지정된 대로 초기화되고, 다른 필드들은 `Point{1.0, 2.0}`과 같은 전통적인 집합체 초기화 표현식과 동일한 방식으로 초기화됩니다.

### 장점
- 지정 초기화자는 특히 위 `Point` 예제보다 필드 순서가 덜 직관적인 구조체의 경우, 편리하고 가독성이 매우 높은 집합체 표현식을 만들 수 있습니다.

### 단점
- 지정 초기화자는 오랫동안 C 표준의 일부였고 C++ 컴파일러에서 확장 기능으로 지원되었지만, C++20 이전에는 C++에서 지원되지 않았습니다.
- C++ 표준의 규칙은 C나 컴파일러 확장 기능보다 더 엄격하여, 지정 초기화자가 구조체 정의에 필드가 나타나는 순서와 동일한 순서로 나타나야 합니다. 따라서 위 예제에서 C++20에 따르면 `x`를 초기화한 다음 `z`를 초기화하는 것은 합법적이지만, `y`를 초기화한 다음 `x`를 초기화하는 것은 불법입니다.

### 의사 결정
지정 초기화자는 C++20 표준과 호환되는 형태로만 사용하세요. 즉, 초기화자가 해당 필드가 구조체 정의에 나타나는 순서와 동일한 순서로 나타나야 합니다.

## 람다 표현식
### 정의
람다 표현식은 익명 함수 객체를 간결하게 만드는 방법입니다. 함수를 인수로 전달할 때 종종 유용합니다.
```cpp
std::sort(v.begin(), v.end(), [](int x, int y) { // 정렬을 위한 비교 함수로 람다 사용
  return Weight(x) < Weight(y);
});
```

또한, 명시적으로 이름을 지정하거나 기본 캡처(default capture)를 사용하여 암시적으로 둘러싸는 범위(enclosing scope)의 변수를 캡처할 수 있습니다.

```cpp
int weight = 3;
int sum = 0;
// `weight`는 값으로, `sum`은 참조로 캡처합니다.
std::for_each(v.begin(), v.end(), [weight, &sum](int x) { sum += weight * x; });

std::unique_ptr<Foo> foo = ...;
[foo = std::move(foo)]() { // foo를 이동하여 캡처
  ...
};

[foo = std::vector<int>({1, 2, 3})]() { // 람다 내부에 새로운 변수 foo를 정의하고 초기화
  ...
};

```

### 장점
- 람다는 STL 알고리즘에 전달할 함수 객체를 정의하는 다른 방법보다 훨씬 간결하여 가독성을 향상시킬 수 있습니다.
- 기본 캡처를 적절히 사용하면 중복을 제거하고 기본값에서 중요한 예외 사항을 강조할 수 있습니다.
- 람다, `std::function`, `std::bind`는 범용 콜백 메커니즘으로 함께 사용될 수 있으며, 바인딩된 함수를 인수로 받는 함수를 쉽게 작성할 수 있게 합니다.

### 단점
- 람다의 변수 캡처는 특히 람다가 현재 범위를 벗어나는 경우 댕글링 포인터(dangling-pointer) 버그의 원인이 될 수 있습니다.
- 값에 의한 기본 캡처([`=`])는 댕글링 포인터 버그를 방지하지 못합니다. 포인터를 값으로 캡처하는 것은 깊은 복사(deep copy)를 유발하지 않으므로, 참조에 의한 캡처와 동일한 수명(lifetime) 문제가 있습니다.
- 캡처는 실제로 새로운 변수를 선언하지만, C++의 다른 어떤 변수 선언 구문과도 전혀 닮지 않았습니다. 특히, 변수의 타입이나 `auto` 플레이스홀더를 위한 공간조차 없습니다.
- 초기화 캡처는 본질적으로 타입 추론에 의존하며, `auto`와 많은 동일한 단점을 겪고, 추가적으로 구문이 추론이 일어나고 있다는 신호조차 리뷰어에게 주지 않는 문제가 있습니다.
- 람다 사용이 과도해질 수 있습니다. 매우 긴 중첩된 익명 함수는 코드를 이해하기 어렵게 만들 수 있습니다.


### 의사 결정
- 캡처는 명시적으로 하는 것을 기본으로 생각하고, 특히 람다의 수명이 불확실하거나 외부로 전달될 때는 반드시 명시적 캡처를 사용합니다.
- 기본 캡처(`[&]`, `[=]`)는 매우 제한적인 상황에서, 그 의미와 위험성을 명확히 인지하고 사용합니다.
- 초기화 캡처는 변수 캡처 본연의 목적에 맞게 사용하고, 새로운 변수 선언의 편법으로 사용하지 않습니다.
- 람다가 너무 복잡해지면 리팩토링을 고려합니다.

## 템플릿 메타프로그래밍
### 정의
템플릿 메타프로그래밍은 C++ 템플릿 인스턴스화 메커니즘이 튜링 완전(Turing complete)하며 타입 도메인에서 임의의 컴파일 시간 계산을 수행하는 데 사용될 수 있다는 사실을 활용하는 일련의 기술을 의미합니다.

### 장점
- 템플릿 메타프로그래밍은 타입 안전하고 고성능인 매우 유연한 인터페이스를 가능하게 합니다. GoogleTest, `std::tuple`, `std::function`, `Boost.Spirit`과 같은 기능들은 이것 없이는 불가능했을 것입니다.

### 단점
- 템플릿 메타프로그래밍에 사용되는 기술들은 언어 전문가가 아닌 사람에게는 종종 모호합니다. 복잡한 방식으로 템플릿을 사용하는 코드는 종종 읽기 어렵고, 디버깅하거나 유지보수하기 어렵습니다.
- 템플릿 메타프로그래밍은 컴파일 타임 오류 메시지가 명확하지 않습니다. 인터페이스가 단순하더라도, 사용자가 무언가를 잘못했을 때 복잡한 구현 세부 사항이 드러나게 됩니다.
- 템플릿 메타프로그래밍은 리팩토링 도구의 작업을 더 어렵게 만들어 대규모 리팩토링을 방해합니다.

### 결정
복잡한 템플릿 프로그래밍을 피하세요.

소수의 핵심적인 저수준 라이브러리나 컴포넌트에서, 그 복잡성과 유지보수 비용을 많은 사용자들이 나눠서 감당할 수 있을 때 사용하는 것이 좋습니다.

템플릿 메타프로그래밍을 사용한다면, 복잡성을 최소화하고 격리하는 데 상당한 노력을 기울여야 합니다. 가능하면 메타프로그래밍을 구현 세부 사항으로 숨겨 사용자 대면 헤더가 읽기 쉽도록 해야 하며, 까다로운 코드는 특히 잘 주석 처리해야 합니다. 코드가 어떻게 사용되는지 신중하게 문서화하고, 생성된 코드가 어떻게 보이는지에 대해 언급해야 합니다. 사용자가 실수를 했을 때 컴파일러가 내보내는 오류 메시지에 각별히 주의를 기울이세요. 오류 메시지는 사용자 인터페이스의 일부이며, 사용자 관점에서 오류 메시지가 이해 가능하고 조치 가능하도록 필요에 따라 코드를 조정해야 합니다.

## Concepts and Constraints
### 정의
`concept` 키워드는 템플릿 매개변수에 대한 요구사항(예: 타입 특성 또는 인터페이스 명세)을 정의하는 새로운 메커니즘입니다. `requires` 키워드는 템플릿에 익명 제약을 가하고 컴파일 시간에 제약이 충족되는지 확인하는 메커니즘을 제공합니다. 컨셉과 제약은 종종 함께 사용되지만, 독립적으로 사용될 수도 있습니다.

### 장점
- 컨셉은 템플릿이 관련된 경우 컴파일러가 훨씬 더 나은 오류 메시지를 생성할 수 있게 하여, 혼란을 줄이고 개발 경험을 크게 향상시킬 수 있습니다.
- 컨셉은 컴파일 시간 제약을 정의하고 사용하는 데 필요한 상용구(boilerplate)를 줄여, 결과 코드의 명확성을 높이는 경우가 많습니다.
- 제약은 템플릿과 SFINAE 기술로는 달성하기 어려운 일부 기능을 제공합니다.
### 단점
- 템플릿과 마찬가지로 컨셉은 코드를 훨씬 더 복잡하고 이해하기 어렵게 만들 수 있습니다.
- 컨셉 구문은 사용되는 위치에서 클래스 타입과 유사하게 보이기 때문에 독자에게 혼란을 줄 수 있습니다.
- 컨셉, 특히 API 경계에서의 컨셉은 코드 결합도(coupling), 경직성(rigidity), 그리고 고착화(ossification)를 증가시킵니다.
- 컨셉과 제약은 함수 본문의 로직을 복제하여 코드 중복 및 유지보수 비용 증가를 유발할 수 있습니다.
- 컨셉은 기본 계약(contract)의 진실의 원천(source of truth)을 흐리게 만듭니다. 컨셉은 여러 위치에서 활용될 수 있는 독립적인 명명된 엔티티이며, 이로 인해 명시된 요구사항과 암시된 요구사항이 시간이 지남에 따라 달라질 수 있습니다.
- 컨셉과 제약은 새롭고 명확하지 않은 방식으로 오버로드 확인(overload resolution)에 영향을 미칩니다.
- SFINAE와 마찬가지로 제약은 대규모 코드 리팩토링을 더 어렵게 만듭니다.
### 의사 결정
- 표준 라이브러리에 미리 정의된 컨셉은 동등한 것이 존재할 경우 타입 특성(type traits)보다 선호되어야 합니다.
- 기존 컨셉이나 특성을 수동으로 다시 구현하지 마세요.
- 새로운 컨셉 선언은 드물어야 하며, 라이브러리 내부에서만 정의되어 API 경계에 노출되지 않도록 해야 합니다. 더 일반적으로, C++17에서 해당 레거시 템플릿 동등물을 사용하지 않았을 경우에는 컨셉이나 제약을 사용하지 마세요.
- 컨셉은 컴파일러에 의해 정적으로 검증 가능해야 합니다. 주된 이점이 의미론적 제약에서 오는 컨셉은 사용하지 마세요. 컴파일 시간에 강제되지 않는 요구사항은 대신 주석, assertion 또는 테스트와 같은 다른 메커니즘을 통해 부과되어야 합니다.

## C++20 모듈
C++20 모듈을 사용하지 마세요.

C++20은 헤더 파일의 텍스트 포함(textual inclusion)에 대한 대안으로 설계된 새로운 언어 기능인 "모듈"을 도입합니다. 이를 지원하기 위해 module, export, import라는 세 가지 새로운 키워드를 도입합니다.

모듈은 C++ 작성 및 컴파일 방식에 큰 변화를 가져오며, 구글의 C++ 생태계에 앞으로 어떻게 부합할 수 있을지 아직 평가 중입니다. 더욱이, 현재 빌드 시스템, 컴파일러 및 기타 도구에서 잘 지원되지 않으며, 작성 및 사용 시 모범 사례에 대한 추가 탐구가 필요합니다.

## Coroutine
코루틴을 (아직) 사용하지 마세요.

`<coroutine>` 헤더를 포함하거나, `co_await`, `co_yield`, 또는 `co_return` 키워드를 사용하지 마세요.
- 이 금지 조항은 추가 지침이 개발되는 동안 일시적일 것으로 예상됩니다.

## Boost
### 정의
Boost 라이브러리 컬렉션은 동료 검토를 거친, 무료, 오픈 소스 C++ 라이브러리의 인기 있는 모음입니다.

### 장점
Boost 코드는 일반적으로 매우 고품질이며, 널리 이식 가능하고, 타입 특성(type traits) 및 더 나은 바인더(binder)와 같이 C++ 표준 라이브러리의 많은 중요한 공백을 메웁니다.

### 단점
일부 Boost 라이브러리는 메타프로그래밍 및 기타 고급 템플릿 기술, 그리고 지나치게 "함수형" 스타일의 프로그래밍과 같이 가독성을 저해할 수 있는 코딩 관행을 조장합니다.

### 의사 결정
코드를 읽고 유지보수할 수 있는 모든 기여자를 위해 높은 수준의 가독성을 유지하기 위해, 우리는 Boost 기능 중 승인된 하위 집합만 허용합니다. 현재는 아래의 라이브러리가 허용됩니다. 
- boost/call_traits.hpp의 Call Traits
- boost/compressed_pair.hpp의 Compressed Pair
- boost/graph의 Boost Graph Library (BGL), 단 직렬화(adj_list_serialize.hpp) 및 병렬/분산 알고리즘 및 데이터 구조(boost/graph/parallel/* 및 boost/graph/distributed/*)는 제외.
- boost/property_map의 Property Map, 단 병렬/분산 프로퍼티 맵(boost/property_map/parallel/*)은 제외.
- boost/iterator의 Iterator
- Polygon 중 보로노이 다이어그램 구성과 관련되고 나머지 Polygon에 의존하지 않는 부분: boost/polygon/voronoi_builder.hpp, boost/polygon/voronoi_diagram.hpp, boost/polygon/voronoi_geometry_type.hpp
- boost/bimap의 Bimap
- boost/math/distributions의 통계적 분포 및 함수
- boost/math/special_functions의 특수 함수
- boost/math/tools의 근 찾기 및 최소화 함수
- boost/multi_index의 Multi-index
- boost/heap의 Heap
- Container의 플랫 컨테이너: boost/container/flat_map 및 boost/container/flat_set
- boost/intrusive의 Intrusive
- boost/sort 라이브러리
- boost/preprocessor의 Preprocessor

## 허용되지 않는 표준 라이브러리 기능
Boost와 마찬가지로, 일부 최신 C++ 라이브러리 기능은 독자에게 도움이 될 수 있는 확인된 중복을 제거하거나 템플릿 메타프로그래밍을 조장하는 등 가독성을 저해하는 코딩 관행을 장려합니다. 다른 확장 기능은 기존 메커니즘을 통해 사용 가능한 기능을 복제하여 혼란과 변환 비용을 초래할 수 있습니다.

다음 C++ 표준 라이브러리 기능은 사용할 수 없습니다.

- 컴파일 시간 유리수 (`<ratio>`), 템플릿 위주의 인터페이스 스타일과 관련이 있다는 우려 때문에.
- `<cfenv>` 및 `<fenv.h>` 헤더, 많은 컴파일러가 해당 기능을 안정적으로 지원하지 않기 때문에.
- `<filesystem>` 헤더, 테스트를 위한 충분한 지원이 없고 내재된 보안 취약점이 있기 때문에.

## 비표준 확장 (Nonstandard Extensions)
### 정의
컴파일러는 표준 C++의 일부가 아닌 다양한 확장을 지원합니다. 이러한 확장에는 GCC의 `__attribute__`, `__builtin_prefetch` 또는 SIMD와 같은 내장 함수(intrinsic functions), `#pragma`, 인라인 어셈블리, `__COUNTER__`, `__PRETTY_FUNCTION__`, 복합 문 표현식(`foo = ({ int x; Bar(&x); x })`), 가변 길이 배열 및 `alloca()`, 그리고 "엘비스 연산자" a?:b가 포함됩니다.

### 장점
- 비표준 확장은 표준 C++에 존재하지 않는 유용한 기능을 제공할 수 있습니다.
- 컴파일러에 대한 중요한 성능 지침은 확장을 사용해야만 지정할 수 있는 경우가 있습니다.

### 단점
- 비표준 확장은 모든 컴파일러에서 작동하지 않습니다. 비표준 확장을 사용하면 코드의 이식성이 저하됩니다.
- 모든 대상 컴파일러에서 지원되더라도 확장은 종종 잘 명시되어 있지 않으며 컴파일러 간에 미묘한 동작 차이가 있을 수 있습니다.
- 비표준 확장은 독자가 코드를 이해하기 위해 알아야 할 언어 기능을 추가합니다.
- 비표준 확장은 아키텍처 간 이식에 추가 작업이 필요합니다.

### 의사 결정
비표준 확장을 사용하지 마세요. 비표준 확장을 사용하여 구현된 이식성 래퍼(portability wrapper)는 사용할 수 있으며, 단 해당 래퍼가 지정된 프로젝트 전체 이식성 헤더에 의해 제공되는 경우에 한합니다.

## 별칭(Alias)
### 정의
다른 엔티티의 별칭이 되는 이름을 만드는 방법에는 여러 가지가 있습니다.
```cpp
using Bar = Foo;                     // Foo 타입에 대한 Bar 별칭 (C++11 이상)
typedef Foo Bar;                     // Foo 타입에 대한 Bar 별칭 (전통적인 방식, C++에서는 using 선호)
using ::other_namespace::Foo;        // 다른 네임스페이스의 Foo를 현재 네임스페이스로 가져옴 (타입 별칭은 아님)
using enum MyEnumType;               // MyEnumType의 모든 열거자를 현재 범위로 가져옴 (C++20 이상)
```
나머지 C++ 구문과 더 일관된 구문과 템플릿 호환을 위해 `typedef`보다 `using`을 사용하는 것이 바람직 합니다.

다른 선언과 마찬가지로, 헤더 파일에 선언된 별칭은 함수 정의 내부, 클래스의 `private` 부분, 또는 명시적으로 내부용으로 표시된 네임스페이스에 있지 않는 한 해당 헤더의 공개 API의 일부입니다. 이러한 영역이나 `.cc` 파일의 별칭은 구현 세부 사항으로 여겨지며, 이 규칙에 의해 제한되지 않습니다.

### 장점
- 별칭은 길거나 복잡한 이름을 단순화하여 가독성을 향상시킬 수 있습니다.
- 별칭은 API에서 반복적으로 사용되는 타입을 한 곳에서 명명함으로써 중복을 줄일 수 있으며, 이는 나중에 타입을 변경하기 더 쉽게 만들 수 있습니다.

### 단점
- 클라이언트 코드가 참조할 수 있는 헤더에 배치될 때, 별칭은 해당 헤더 API의 엔티티 수를 늘려 복잡성을 증가시킵니다.
- 클라이언트는 공개 별칭의 의도하지 않은 세부 사항에 쉽게 의존하게 되어 변경을 어렵게 만듭니다.
- API나 유지보수성에 미치는 영향을 고려하지 않고, 단지 구현에서의 사용만을 의도한 공개 별칭을 만들고 싶은 유혹이 있을 수 있습니다.
- 별칭은 이름 충돌의 위험을 만들 수 있습니다.
- 별칭은 익숙한 구성 요소에 익숙하지 않은 이름을 부여하여 가독성을 저해할 수 있습니다.
- 타입 별칭은 불명확한 API 계약을 만들 수 있습니다: 별칭이 현재 별칭으로 지정된 타입과 동일하다고 보장되는지, 동일한 API를 갖는다고 보장되는지, 아니면 지정된 좁은 방식으로만 사용 가능하다고 보장되는지가 불분명합니다.

### 의사 결정
- 단순히 구현에서 타이핑을 절약하기 위해 공개 API에 별칭을 넣지 마세요. 클라이언트가 사용하도록 의도한 경우에만 그렇게 하세요.
- 공개 별칭을 정의할 때는, 현재 별칭으로 지정된 타입과 항상 동일하다고 보장되는지 또는 더 제한된 호환성이 의도되는지를 포함하여 새 이름의 의도를 문서화하세요. 이를 통해 사용자는 타입을 대체 가능하게 취급할 수 있는지 또는 더 구체적인 규칙을 따라야 하는지를 알 수 있으며, 구현이 별칭을 변경할 수 있는 어느 정도의 자유를 유지하는 데 도움이 될 수 있습니다.
- 공개 API에 네임스페이스 별칭을 넣지 마세요.


## `switch` 문
열거형 값에 대한 조건이 아니라면, `switch` 문은 항상 default 케이스를 가져야 합니다. 만약 `default` 케이스가 절대로 실행되어서는 안 된다면, 이를 오류로 처리하세요.

C++17 이상에서 의도적인 폴스루는 반드시 `[[fallthrough]];` 속성으로 명시해야 합니다.
```cpp
switch (x) {
  case 41:  // 여기에는 명시 필요 없음.
  case 43:
    if (dont_be_picky) {
      // 주석의 명시 대신 또는 함께 이것을 사용하세요.
      [[fallthrough]];
    } else {
      CloseButNoCigar();
      break;
    }
  case 42:
    DoSomethingSpecial();
    [[fallthrough]]; // case 42에서 default로 폴스루
  default:
    DoSomethingGeneric();
    break;
}
```