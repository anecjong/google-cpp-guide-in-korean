# Google-Specific Magic
이 섹션은 Google 내부에서 C++를 사용할 때 따르는 특별한 관례나 도구, 접근 방식을 소개하는 부분입니다. 일반적인 C++ 관행과 다를 수 있는 Google만의 스타일이나 권장 사항을 다룹니다.

## 소유권과 스마트 포인터
### 정의
**소유권(Ownership)**은 동적으로 할당된 메모리(및 기타 리소스)를 관리하기 위한 기록 관리 기법입니다. 동적으로 할당된 객체의 소유자인 객체 또는 함수는 더 이상 필요하지 않을 때 해당 객체가 삭제되도록 보장할 책임이 있습니다. 소유권은 공유될 수 있으며, 이 경우 마지막 소유자가 삭제를 책임집니다. 소유권이 공유되지 않는 경우에도, 한 함수 또는 객체에서 다른 함수 또는 객체로 소유권이 이전될 수 있습니다.

스마트 포인터는 RAII 패턴을 포인터에 적용한 것으로 생성될 때 리소스를 획득하고, 소멸될 때 리소스를 자동으로 해제합니다.
- `std::unique_ptr`
    - 유일한 소유자를 의미합니다.
    - 복사가 금지되어 실수로 여러 곳에서 같은 메모리를 소유하려는 상황을 막습니다.
    - 소유권을 이전하려면 `std::move`를 사용해야 합니다.
- `std::shared_ptr`
    - 공유 소유자를 의미합니다.
    - 내부적으로 참조 카운트를 사용해 얼마나 많은 `shared_ptr`가 객체를 참조하는지 추적합니다.
    - 참조 카운트가 0이되면 객체를 삭제합니다.

### 장점
- 소유권 로직 없이는 동적으로 할당된 메모리를 관리하는 것이 거의 불가능합니다.
- 객체의 소유권을 이전하는 것이 객체를 복사하는 것보다 비용이 적게 들 수 있습니다
- 여러 사용자 사이에서 객체의 생명 주기를 조정할 필요성을 줄여주기 때문에 소유권을 이전하는 것이 포인터나 참조를 '빌리는' 것보다 간단할 수 있습니다.
> 빌려준 쪽에서 객체를 먼저 해제하는 것을 걱정하지 않아도 됩니다.
- 스마트 포인터는 소유권 로직을 명시적이고, 자체 문서화되며, 모호하지 않게 만들어 가독성을 향상시킬 수 있습니다.
- 스마트 포인터는 수동적인 소유권 기록 관리를 제거하여 코드를 단순화하고 많은 종류의 오류를 배제할 수 있습니다.
- `const` 객체의 경우, 공유 소유권은 깊은 복사(deep copying)에 대한 간단하고 효율적인 대안이 될 수 있습니다.

### 단점
- 소유권은 포인터를 통해 표현되고 이전되어야 합니다. 포인터 의미론은 값 의미론보다 복잡하며, 특히 API에서는 소유권뿐만 아니라 앨리어싱(aliasing), 생명 주기, 변경 가능성 등 다른 문제들에 대해서도 걱정해야 합니다.
- 값 의미론(value semantics)의 성능 비용은 종종 과대평가되므로, 소유권 이전의 성능 이점이 가독성 및 복잡성 비용을 정당화하지 못할 수도 있습니다.
- 소유권을 이전하는 API는 클라이언트에게 단일 메모리 관리 모델을 강요합니다.
- 스마트 포인터를 사용하는 코드는 리소스 해제가 어디서 일어나는지 덜 명시적입니다.
- `std::unique_ptr`는 이동 의미론(move semantics)을 사용하여 소유권 이전을 표현하는데, 이는 비교적 새로운 개념이어서 일부 프로그래머에게 혼란을 줄 수 있습니다.
- 공유 소유권은 신중한 소유권 설계를 회피하는 유혹적인 대안이 될 수 있어 시스템 설계를 모호하게 만들 수 있습니다.
- 공유 소유권은 런타임에 명시적인 기록 관리를 필요로 하며, 이는 비용이 많이 들 수 있습니다.
- 순환 참조 등에 의해 공유 소유권을 가진 객체는 절대 삭제되지 않을 수 있습니다.
- 스마트 포인터는 일반 포인터의 완벽한 대체재는 아닙니다. 단순히 객체를 관찰하는 경우에는 일반 포인터나 참조가 적절할 수 있습니다.

### 의사 결정
- 동적 할당이 필요하다면, 할당한 코드에 소유권을 유지하는 것을 선호하세요. 다른 코드가 객체에 접근해야 한다면, 복사본을 전달하거나 소유권을 이전하지 않고 포인터나 참조를 전달하는 것을 고려하세요. 소유권 이전을 명시적으로 만들기 위해 `std::unique_ptr`를 사용하는 것을 선호하세요.
- 타당한 이유 없이 공유 소유권을 사용하도록 코드를 설계하지 마세요. 그러한 이유 중 하나는 비용이 많이 드는 복사 연산을 피하기 위함이지만, 성능 이점이 상당하고 기존 객체가 불변(immutable)인 경우에만 수행해야 합니다. 공유 소유권을 사용한다면 `std::shared_ptr`을 사용하는 것을 선호하세요.

## cpplint
스타일 오류를 감지하기 위해 `cpplint.py`를 사용하세요. `cpplint.py`는 소스 파일을 읽고 많은 스타일 오류를 식별하는 도구입니다. 완벽하지 않으며, 잘못된 경고(false positives)와 놓치는 오류(false negatives)가 모두 있지만, 여전히 가치 있는 도구입니다.
> https://github.com/cpplint/cpplint