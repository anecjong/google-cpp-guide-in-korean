# 스코핑(Scoping)

## 네임스페이스(Namespaces)

네임스페이스는 전역 범위를 별개의 명명된 스코프로 세분화하므로 전역 범위에서 이름 충돌을 방지하는 데 유용합니다. 몇 가지 예외를 제외하고, 코드는 네임스페이스 안에 배치하세요. 네임스페이스는 프로젝트 이름과 가능하다면 경로를 기반으로 한 고유한 이름을 가져야 합니다. `using` 지시문(예: `using namespace foo`)은 사용하지 마세요. 인라인 네임스페이스도 사용하지 마세요.

### 정의
네임스페이스는 전역 스코프를 구별 가능한 이름을 가진 스코프로 나누며, 전역 스코프에서 이름 충돌을 막는데 유용합니다.

### 장점
- 이름 충돌을 방지하는 방법을 제공하면서 대부분의 코드가 간결한 이름을 사용할 수 있습니다.
- 인라인 네임스페이스는 그 안의 멤버들이 바깥쪽 네임스페이스에 직접 속한 것처럼 접근할 수 있게 해줍니다.

### 단점
- 어떤 정의가 어떤 이름을 참조하는지 판단하는 것을 복잡하게 만듭니다.
- 인라인 네임스페이스는 이름이 선언된 곳과 실제 접근되는 스코프가 달라 혼란을 줄 수 있습니다.
- 네임스페이스가 깊게 중첩되면 `very::long::namespace::name::MyClass`처럼 이름이 매우 길어져 코드 가독성을 해칠 수 있습니다.

### 의사 결정
- 네임스페이스 이름 규칙을 따라야 합니다.
  - `snake_case`
  - 해당 네임스페이스 외부에서 이름을 사용할 때는 완전 정규화된 이름을 사용하세요.
  - 최상위 네임스페이스는 단일 프로젝트나 팀이 소유해야하며, 해당 프로젝트나 팀의 이름을 기반으로 이름을 가져야 합니다.
  - 코드의 물리적인 디렉토리 구조와 네임스페이스 구조를 일치시키는 것이 일반적입니다. (project_name/component_a/ 디렉토리 아래 코드는 `project_name::component_a` 네임스페이스 사용)
  - `std`나 `absl`과 같이 널리 사용되는 최상위 네임스페이스 이름을 중첩 네임스페이스 이름으로 사용하지 않습니다.
- 네임스페이스 끝에는 네임스페이스의 이름을 주석으로 명시해야 합니다. (`} // namespace my_namespace`)
- 네임스페이스 범위는 `#include`, `gflags` 정의/선언, 다른 네임스페이스 클래스 속한 클래스의 전방선언 바로 다음부터 시작하여 파일의 나머지 코드를 감싸야 합니다.
- 프로토콜 버퍼 컴파일러가 생성하는 코드를 특정 네임스페이스에 위치시키려면, `.proto` 파일 내에서 package 지정자를 사용해야 합니다. 참고 링크: https://protobuf.dev/reference/cpp/cpp-generated/#package
- `namespace std` 안에는 절대 어떤 것도 선언해서는 안 됩니다. `std` 네임 스페이스에 무언가 추가하는 행위는 C++ 표준에 의해 정의되지 않은 동작으로 간주되며, 이식성이 없는 코드가 됩니다.
- `using namespace foo`와 같이 네임스페이스 모든 이름을 현재 범위로 가져오는 것은 금지됩니다.
- 헤더 파일에서 네임스페이스 별칭(alias, `namespace fs = std::filesystem;`)은 일반적으로 금지되며 예외적으로 내부 전용으로 표시된 네임스페이스 안에서는 허용될 수 있습니다. 헤더 파일에서 정의된 네임스페이스 별칭은 이 헤더를 포함하는 모든 파일에 영향을 미치며 사실상 공개된 API의 일부가 되어 의도치 않은 이름 충돌이나 API의 복잡성을 증가시킬 수 있습니다.
```cpp
// Shorten access to some commonly used names in .cc files.
namespace baz = ::foo::bar::baz;

// Shorten access to some commonly used names (in a .h file).
namespace librarian {
namespace internal {  // Internal, not part of the API.
namespace sidetable = ::pipeline_diagnostics::sidetable;
}  // namespace internal

inline void my_inline_function() {
  // namespace alias local to a function (or method).
  namespace baz = ::foo::bar::baz;
  ...
}
}  // namespace librarian
```
- 인라인 네임스페이스를 사용하지 마세요. (`inline namespace v1 { ... }`)
- API의 일부이지만 사용자가 직접 호출하거나 의존해서는 안 되는 부분들은 네임스페이스 이름에 "internal"과 같은 단어를 포함시켜 문서화해야 합니다. 이는 언제든 제거될 수 있음을 명확히 알리는 역할입니다.
- 각 라이브러리는 고유한 `internal` 네임스페이스를 가져야 합니다. `gshoe` 네임스페이스 아래에 `widget.h`라는 파일이 있다면 `gshoe::internal_widget`과 같이 더 구체적인 네임스페이스를 사용해야 충돌을 방지할 수 있습니다.
- C++17 이상의 새로운 코드에서는 단일행으로 중첩된 네임스페이스를 선언하는 것이 권장됩니다. `namespace foo::bar { ... }` 형태는 필수는 아니지만, 코드를 더 간결하게 만들 수 있기 때문에 권장됩니다.

## 내부 연결(Internal Linkage)

### 정의
내부 연결은 어떤 심볼이 오직 현재 컴파일 단위(translation unit, 보통 하나의 `.cc` 파일) 내에서만 접근 가능하도록 제한하는 C++의 특성입니다. 모든 선언은 이름 없는 네임스페이스에 배치하거나 `static`으로 선언함으로써 내부 링키지를 가질 수 있습니다. 만약 다른 파일에서 같은 이름으로 무언가를 선언한다면, 그 두 엔티티는 완전히 독립적입니다.

### 의사 결정
- `.cc` 파일의 정의가 해당 파일 외부에서 참조될 필요가 없을 때, 익명 네임스페이스에 배치하거나 `static`으로 선언하여 내부 링크를 제공하세요. `.h` 파일에서는 이러한 구성을 사용하지 마세요.
- 익명 네임스페이스는 명명된 네임스페이스와 같은 형식으로 지정합니다. 종료 주석에서는 네임스페이스 이름을 비워 두세요.

```cpp
// 익명 네임스페이스 사용 - 권장됨
namespace
{
void HelperFunction()
{
    ...
} // 이 파일에서만 사용 가능
} // namespace

// static 키워드 사용
static int counter = 0; // 이 파일에서만 사용 가능
```

## 비멤버, 정적 멤버, 전역 함수

### 장점
- 비멤버, 정적 멤버 함수는 특정 상황에서 유용할 수 있습니다. 비멤버 함수를 네임스페이스에 두는 것은 전역 네임스페이스를 오염시키는 것을 피할 수 있습니다.

### 단점
- 비멤버, 정적 멤버 함수는 외부 자원과 의존성이 있는 경우 새로운 클래스의 멤버일 때 더 자연스러울 수 있습니다.

### 의사 결정

- 비멤버 함수(어떤 클래스에도 속하지 않는 함수, 일반 함수)는 네임스페이스에 배치하는 것이 좋으며, 완전히 전역 함수는 특별한 경우가 아니면 사용하지 마세요.
- 단순히 정적 멤버를 그룹화하기 위해 클래스를 사용하지 마세요. 클래스의 정적 메서드는 일반적으로 클래스의 인스턴스나 클래스의 정적 데이터와 밀접하게 관련되어야 합니다.
> MathUtils 클래스에 static int add(...), static int subtract(...) 등 함수만 두는 것은 권장되지 않으며, 네임스페이스가 더 적절한 해결책입니다.

## 지역 변수(Local Variable)

함수의 변수를 가능한 가장 좁은 범위에 배치하고, 선언에서 변수를 초기화하세요. 이렇게 하면 코드를 읽는 사람이 선언을 찾고 변수의 유형과 초기화된 값을 쉽게 확인할 수 있습니다.

```cpp
int i;
i = f();      // 나쁨 -- 초기화가 선언과 분리됨.
int i = f();  // 좋음 -- 선언에 초기화가 포함됨.

int jobs = NumJobs();
// ...
// 중간의 많은 코드들
// ...
f(jobs);      // 나쁨 -- 선언이 사용과 분리됨.

int jobs = NumJobs();
f(jobs);      // 좋음 -- 선언 직후(또는 가까이) 사용됨.

std::vector<int> v;
v.push_back(1);  // 중괄호 초기화를 사용하는 것이 권장됨.
v.push_back(2);
std::vector<int> v = {1, 2};  // 좋음 -- v가 초기화된 상태로 시작함.
```

`if`, `while`, `for` 문에서 필요한 변수는 일반적으로 해당 제어문의 조건 부분이나 초기화 부분에 선언하여 변수의 범위를 해당 제어문 블록으로 고정해야 합니다. 주의사항으로 지역 변수가 객체라면, 해당 변수가 선언된 범위에 진입할 때마다 생성자가 호출되고, 범위를 벗어날 때마다 소멸자가 호출되어 비효율적일 수 있습니다. 이 경우 제어문 밖에서 초기화하는 것이 효율적입니다.

```cpp
while (const char* p = strchr(str, '/'))
{
    // p는 이 while 루프 안에서만 유효
    str = p + 1;
}
// 여기서 p는 더 이상 접근 불가능

// 비효율적인 구현
for (int i = 0; i < 1000000; ++i)
{
    Foo f; // 생성자, 소멸자가 1000000 번 호출됨.
    f.DoSomething(i);
}

// 효율적인 구현
Foo f; // 생성자, 소멸자가 1번 호출됨.
for (int i = 0; i < 1000000; ++i)
{
    f.DoSomething(i);
}
```

## 정적 및 전역 변수(Static and Global Variables)
### 정의
모든 객체는 자신의 생명주기(lifetime)와 관련된 저장 기간을 가집니다. 정적 저장 기간(static stroage duration)을 가진 객체들은 전역 변수, 클래스의 정적 데이터 멤버, 함수 내 지역 변수이 있으며 초기화 시점부터 프로그램 종료까지 살아 있습니다.

초기화는 아래의 두 가지 방식이 있습니다.
- 동적 초기화(Dynamic Initialization): 초기화 과정에서 자명하지 않은 작업이 수행되는 방식으로 메모리 할당, 현재 프로세스 ID로 초기화되는 변수 등 런타임에 결정되는 값으로 초기화하는 방식입니다.
- 정적 초기화(Static Initialization): 정적 저장 기간을 객체는 먼저 정적 초기화가 발생됩니다. 이는 객체를 주어진 상수 값으로 초기화하거나, 모든 바이트를 0으로 설정된 표현으로 초기화하는 것을 의미합니다.
두 개념은 반대되는 개념이 아니며, 정적 저장 기간 객체는 먼저 정적 초기화가 이루어지고, 동적 초기화가 필요하다면 그 이후에 수행됩니다.

> 자명하지 않은(non-trivial) 작업의 예시
> - 메모리 관리: `new`, `delete`
> - 자원 관리: 생성자에서 파일 핸들, 네트워크 소켓, 뮤텍스 등 시스템 자원을 획득하고 소멸자에서 이러한 자원을 해제
> - 가상 함수: 클래스가 가상함수를 가지고 있거나 가상 함수를 가진 클래스를 상속받는 경우 가상 함수 테이블(vtable) 설정 등 추가 작업 필요
> - 복잡한 멤버 변수 초기화/해제
> - 사용자 정의 로직: 생성자나 소멸자 내부에 프로그래머가 명시적으로 작성한 특정 로직

### 장점
- 다양한 애플리케이션에서 유용합니다.
  - 이름 있는 상수 (named constant)
  - 특정 컴파일 단위 내부에서 사용되는 보조 자료 구조
  - 명령줄 플래그 (command-line flags)
  - 로깅
  - 등록 메커니즘
  - 백그라운드 인프라스트력쳐

### 단점
- 동적 초기화를 사용하거나 자명하지 않은 소멸자를 가진 전역/정적 변수는 찾기 어려운 버그로 이어질 수 있습니다.
- 서로 다른 컴파일 단위에 있는 전역/정적 변수들의 동적 초기화 순서는 C++ 표준에 의해 보장되지 않습니다. 소멸 순서 또한 보장되지 않습니다.
- 한 전역/정적 변수의 초기화가 다른 전역/정적 변수를 참조할 때, 참조되는 변수가 아직 초기화되지 않았거나 이미 소멸되었을 가능성이 있습니다.
- 프로그램 종료 시 `join`되지 않은 스레드가 있다면, 이 스레드들이 이미 소멸자가 실행된 전역/정적 객체에 접근하려고 시도할 수 있습니다.

### 소멸자에 대한 의사 결정

소멸자가 자명할 때, 그 실행은 전혀 순서에 종속되지 않습니다. 소멸자가 자명하지 않다면 객체의 수명이 끝난 후 접근할 위험에 노출됩니다. 따라서 정적 저장 기간을 가진 객체는 자명하게 소멸 가능한 경우에만 허용합니다. 기본 타입(포인터나 `int`와 같은 타입)은 자명하게 소멸 가능하며, 자명하게 소멸 가능한 타입의 배열도 마찬가지입니다. `constexpr`로 표시된 변수는 자명하게 소멸 가능함에 유의하세요.

```cpp
const int kNum = 10; // 허용됨

struct X
{
    int n;
};
const X kX[] = {{1}, {2}, {3}}; // 허용됨

void foo()
{
    static const char* const kMessages[] = {"hello", "world"}; // 허용됨
}

// 허용됨: constexpr는 자명한 소멸자를 보장합니다.
constexpr std::array<int, 3> kArray = {1, 2, 3};

// 나쁨: 자명하지 않은 소멸자
// 문열 데이터 저장하기 위해 사용된 동적 메모리를 소멸 시에 해제해야 한다.
const std::string kFoo = "foo";

// 같은 이유로 나쁨, kBar가 참조일지라도
// (이 규칙은 수명이 연장된 임시 객체에도 적용됩니다).
const std::string& kBar = StrCat("a", "b", "c");

void bar()
{
    static std::map<int, int> kData = {
        {1, 0},
        {2, 0},
        {3, 0}
    }; // 나쁨: 자명하지 않은 소멸자.
}
```

참조는 객체가 아니므로 소멸 가능성에 대한 제약을 받지 않습니다. 하지만 동적 초기화에 대한 제약은 여전히 적용됩니다. 특히, static T& t = *new T; 형태의 함수 지역 정적 참조는 허용됩니다. 이 객체 자체는 프로그램 종료 시 자동으로 해제되지 않으므로 메모리 누수가 발생할 수 있으나, 스타일 가이드에서는 이 패턴 자체는 허용합니다.

### 초기화에 대한 의사 결정

초기화는 더 복잡한 주제로, 클래스 생성자가 실행되는지 뿐만 아니라 초기화 표현식 자체의 평가 방식도 고려해야 합니다.
```cpp
int n = 5;    // 괜찮음
int m = f();  // ? (f에 따라 다름)
Foo x;        // ? (Foo::Foo에 따라 다름)
Bar y = g();  // ? (g와 Bar::Bar에 따라 다름)
```
첫 번째 줄을 제외하고는, 모두 비결정적인 초기화 순서 문제에 영향을 받을 수 있습니다.

상수 초기화는 C++ 표전에서 정의하는 개념으로 컴파일 타임에 변수의 초기화가 완료되는 것을 의미합니다. 객체가 생성자 호출로 초기화된다면, 해당 생성자도 `constexpr`로 정의되어야 합니다.

```cpp
struct Foo { constexpr Foo(int) {} };

int n = 5;  // 괜찮음, 5는 상수 표현식입니다.
Foo x(2);   // 괜찮음, 2는 상수 표현식이고 선택된 생성자는 constexpr입니다.
Foo a[] = { Foo(1), Foo(2), Foo(3) };  // 괜찮음
```

상수 초기화는 항상 허용됩니다. 정적 저장 기간을 가진 변수의 상수 초기화는 `constexpr`(C++11) 또는 `constinit`(C++20)으로 표시되어야 합니다. 이렇게 표시되지 않은 비지역(non-local) 정적 저장 기간 변수는 동적 초기화를 가진 것으로 추정되며, 매우 신중하게 검토되어야 합니다.

상수 초기화와 반대로 다음 초기화는 문제가 있습니다:
```cpp
// 일부 아래에서 사용되는 선언.
time_t time(time_t*);
int f();
struct Bar { Bar() {} };

// 문제가 있는 초기화.
time_t m = time(nullptr);  // time 함수는 constexpr이 아님.
Foo y(f());                // f 함수는 constexpr이 아님.
Bar b;                     // Bar::Bar 생성자는 constexpr이 아님.
```

비지역 변수의 동적 초기화는 권장되지 않으며, 일반적으로 금지됩니다. 예외적으로, 프로그램의 어떤 측면도 다른 모든 초기화의 순서에 의존하지 않는 경우에는 허용합니다. 이러한 제한 사항 하에서, 초기화 순서는 관찰 가능한 차이를 만들지 않습니다. 예를 들어:

```cpp
int p = getpid();  // 허용됨, 다른 정적 변수가 초기화에서 p를 사용하지 않는 한.
```

함수의 지역 정적 변수(static function-local varaible)의 동적 초기화는 허용됩니다(그리고 일반적입니다).

### 일반적인 패턴

- **전역 문자열**: 명명된 전역 또는 정적 문자열 상수가 필요한 경우, 문자열 리터럴을 가리키는 `constexpr std::string_view`, 문자 배열 또는 문자 포인터 변수를 사용하는 것을 고려하세요. 문자열 리터럴은 이미 정적 저장 기간을 가지며 일반적으로 충분합니다. `std::string` 자체는 자명하지 않은 소멸자를 가져 부적합합니다.
- **map, set 및 기타 동적 컨테이너**: 정적이고 고정된 컬렉션(예: 검색할 집합이나 조회 테이블)이 필요한 경우, 자명한 소멸자를 가지지 않기 때문에 표준 라이브러리의 동적 컨테이너를 정적 변수로 사용할 수 없습니다. 대신, 간단한 자명한 타입의 배열을 고려하세요. 예를 들어, `int` 배열의 배열("`int`에서 `int`로의 맵") 또는 페어 배열(예: `int`와 `const char*`의 페어)을 사용할 수 있습니다. 작은 컬렉션의 경우, 선형 검색은 완전히 충분합니다(그리고 메모리 지역성으로 인해 효율적임). 표준 연산에 대해 `absl/algorithm/container.h`의 기능을 사용하는 것을 고려하세요. 필요한 경우, 컬렉션을 정렬된 상태로 유지하고 이진 검색 알고리즘을 사용하세요. 정말로 표준 라이브러리의 동적 컨테이너를 선호한다면, 아래에 설명된 대로 함수-지역 정적 포인터를 사용하는 것을 고려하세요.
- **스마트 포인터(std::unique_ptr, std::shared_ptr)**: 스마트 포인터는 소멸 중에 정리를 실행하므로 금지됩니다. 사용 사례가 이 섹션에 설명된 다른 패턴 중 하나에 맞는지 고려하세요. 한 가지 간단한 해결책은 동적으로 할당된 객체를 가리키는 일반 포인터를 사용하고 절대 삭제하지 않을 수 있습니다.
- **커스텀 타입의 정적 변수**: 직접 정의해야 하는 타입의 정적, 상수 데이터가 필요한 경우, 그 타입에 자명한 소멸자와 `constexpr` 생성자를 제공하세요.
- **다른 모든 방법이 실패하면**, 함수-지역 정적 포인터나 참조를 사용하여 객체를 동적으로 생성하고 절대 삭제하지 않을 수 있습니다(예: `static const auto& impl = *new T(args...);`).

## `thread_local` 변수

### 정의
`thread_local` 지정자로 변수를 선언해 사용할 수 있습니다. `thread_local` 변수는 실제로는 객체들의 컬렉션으로 서로 다른 스레드가 이 변수에 접근할 때 각 스레드마다 고유한, 별개의 객체에 접근하게 됩니다.
### 장점
- 경쟁 상태(race condition)으로 부터 안전합니다.
- C++ 표준에서 스레드 로컬 데이터를 생성하는 유일한 방법입니다.
### 단점
- `thread_local` 변수에 처음 접근하거나 스레드가 시작될 때, 해당 변수의 초기화를 위해 예측하거나 제어하기 어려운 코드가 실행될 수 있습니다.
- 스레드 안정성 부족 문제 해결을 제외하면, 사실상 전역 변수와 같으며 전역 변수가 가지는 모든 단점(코드 결합도 증가, 테스트 어려움)을 가집니다.
- 실행 중인 스레드 수에 비례해 메모리 사용량이 증가합니다.
- 데이터 멤버는 `static`이 아닌 이상 `thread_local`로 선언될 수 없습니다.
- `thread_local` 변수가 복잡한 소멸자를 가질 경우 사용 후 해제 버그를 겪을 수 있습니다. 특히 어떤 `thread_local` 변수의 소멸자는 이미 소멸되었을 가능성이 있는 다른 `thread_local` 변수를 참조하는 코드를 호출해서는 안 되만, 이 속성을 강제하기는 어렵습니다.
- 전역/정적 변수 회피 전략의 비적용
  - 전역/정적 변수는 프로그램 종료 시 소멸자를 건너뛰는 의도적 누수가 허용될 수 있습니다. 이들의 수명은 프로그램 종료와 함께 끝나고 OS가 즉시 메모리와 자원을 정리해주기 때문입니다.
  - 반면, `thread_local` 변수의 소멸자를 건너뛰면, 프로그램 수명 동안 종료되는 스레드의 총 수에 비례하는 자원 누수가 발생합니다.

### 의사 결정
- 클래스/전역 범위 `thread_local` 변수는 반드시 컴파일 타임 상수로 초기화되어야 하며 `constinit`, `constexpr`로 작성되어야 합니다.
- 함수 내부의 `thread_local` 변수는 초기화 관련 문제는 없지만 스레드 종료 시 사용 후 해제 위험이 있습니다.
- 다른 `thread_local` 변수에 접근할 가능성을 최소화하기 위해 자명한 타입이나 소멸 시 유저 코드를 실행하지 않는 타입을 사용해야 합니다.
- 해당 기능을 사용하기 위해 다른 비표준 방식보다 C++ 표준 `thread_local` 방식을 사용하는 것을 권장합니다.

> `thread_local`은 다음과 같은 경우에 특정 문제를 해결하기 위한 트레이드 오프로서 고려될 수 있다.
> 기존 코드와의 호환성이 매우 중요하고 대규모 리팩토링이 어려운 경우.
> 함수 시그니처 변경 없이 암묵적인 스레드별 컨텍스트 정보를 전달해야 하는 명확한 요구사항이 있는 경우 (예: 로깅, 트레이싱).
> C API 연동 등 명시적 데이터 전달이 극히 제한적인 경우.